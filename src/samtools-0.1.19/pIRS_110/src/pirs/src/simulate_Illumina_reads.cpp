#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <cmath>
#include <stdint.h>
#include <map>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>
#include "gzstream.h"
#include "simulate.h"
#include "load_file.h"
#include "MaskQvalsByEamss.h"
#include "global.h"

using namespace std;

/*parameter variable:

  int Read_length;
  int Insertsize_mean;
  int Insertsize_sd;
	int Is_simulate_InDel;
  int Is_cyclization;
  int Is_simulate_GC_bias;
  int Is_simulate_quality;
  int Q_Mode;
  int Q_shift;
  int Mask_quality_mode;
  int Output_type;
  double Coverage;
  double Error_rate;
	string Input_ref1;
  string Input_ref2;
  string BaseCalling_profile;
  string GC_depth_profile;
  string InDel_error_profile;
  string Output_prefix;
 */
PARAMETER InputParameter ={100,500,-1,1,0,1,1,1,64,0,1,5,-1,"","","","","","Illumina"};

int Ref_Base_num = 0;  //ATCG: 4
int Statistical_Cycle_num = 0; //the cycle number in Base-calling profile
int Seq_Base_num = 0;  //ATCG: 4
int Quality_num = 0;  //the quality score number in Base-calling profile
int Simulate_Cycle_num = 0; //the cycle number of simulation
double Statistical_average_error_rate = 0; //the average error rate in Base-calling profile

int Statistical_Cycle_num2 = 0; //the cycle number in InDel-error profile
double** InDel_error_matrix = NULL; //for simulating InDel-error in reads
int* InDel_num = NULL; //for getting indel number
int InDel_max_len = 0;
uint64_t Read1_ins_sum = 0;
uint64_t Read1_del_sum = 0;
uint64_t Read2_ins_sum = 0;
uint64_t Read2_del_sum = 0;

ogzstream Gz_outfile1; 
ogzstream Gz_outfile2;
ofstream Outfile1;
ofstream Outfile2;

ogzstream Infor_outfile;

double*** First_cycle_matrix = NULL;  //for calling base and Qtran simulation, get the first cycle matrix
double*** Simulation_matrix1 = NULL;  
double**** Simulation_matrix2 = NULL;
double* GC_bias_abundance = NULL;  //for simulation GC bias 
map<int,uint64_t> InsertSize_distr; //record the insert size distribution 
uint64_t* Error_pos_distr = NULL; //record the error position distribution
double* Q_to_Erate_distr = NULL; //record quality score to error rate distribution
uint64_t Total_read_pair = 0; 

int *Qval2Qval = NULL; //for shifting quality value while change the substitution-error rate

//get genome sequence and start to simulate read 
void Get_genome(igzstream &inf,igzstream &inf2);
//contral the quantity of simulate reads for each chromosome one by one
uint64_t contral_reads_quantity(string id_line,string id,string &sequ,string &sequ2,uint64_t read_genome);
//simulate reads
uint64_t simulate_reads(string &seq,uint64_t seqlen, uint64_t rd_pair, string id_seq, int i_or_I, uint64_t reads_all);


void SimReads_Usage(){
	cout<<"\nDescription:"<<endl;
	cout<<"   It is a program for simulating Illumina pair-end reads, with a series of characters generate by illumina ";
	cout<<"sequencing platform, such as insertsize distribution, sequencing error(substitution, insertion, deletion), quality score and GC bias. ";
	cout<<"User should set the mean value and the standard deviation of the normal distribution for simulating insertsize ";
	cout<<"distribution, usually we set the insertsize_sd as 1/20 of the insertsize_mean. The normal distribution ";
	cout<<"function model we used in this program is simulated by Box-muller method. ";
	cout<<"This program simulates Illumina sequencing error, quality score and GC bias according to the empirical distribution profile. ";
	cout<<"User can set the path of profile or using the default file in this program package, which is generated by large real sequencing data. ";
	cout<<"It need two reference genome sequence if you want to simulate reads of diploid(heterozygosis SNP, heterozygosis Indel and structural variation), ";
	cout<<"you can get another diploid genome sequence by the command \"pirs diploid\", but remember that heterozygosis SNP rate and heterozygosis Indel rate only exist in diploid. \n";
	cout<<endl<<"Program: pirs simulate"<<endl;
	cout<<endl<<"Usage:\t./pirs simulate [options]"<<endl;
	cout<<"\t-i  <string>  input_ref1, input reference genome sequence *.fa/*.fa.gz, no default vaule"<<endl;
	cout<<"\t-I  <string>  input_ref2, for diploid genome, input another reference genome sequence which was generated by command \"pirs diploid\""<<endl;
	cout<<"\t-s  <string>  Base-calling profile, input Base-calling profile for simulating substitution-error and quality score,default: (exe_path)"<<BASE_CALLING_PROFILE<<endl;
	cout<<"\t-d  <string>  GC content-coverage profile, input GC content-coverage file for simulating GC bias, the default profile are determined based on the twice of read length"<<endl;
	cout<<"\t-b  <string>  InDel-error profile, input InDel-error profile for simulating InDel-error of reads, default:(exe_path)"<<INDEL_ERROR_PROFILE<<endl;
	cout<<"\t-l  <int>     read_len, set length of read, read1 and read2 have the same length,default:"<<InputParameter.Read_length<<endl;
	cout<<"\t-x  <double>  coverage, set the sequencing coverage(sometimes called depth),default:"<<InputParameter.Coverage<<endl;
	cout<<"\t-m  <int>     insertsize_mean, set the average value of insert size,default:"<<InputParameter.Insertsize_mean<<endl;
	cout<<"\t-v  <int>     insertsize_sd, set the standard deviation of insert sizes, default:insertsize_mean/20"<<endl;
	cout<<"\t-e  <double>  substitution-error rate, set the average substitution-error rate(0 or 0.0001~0.63) over all cycles, default=average substitution-error rate of Base-calling profile"<<endl;
	cout<<"\t-a  <int>     simulate reads indel, 0:no, 1:yes. default:"<< InputParameter.Is_simulate_InDel<<endl;
	cout<<"\t-g  <int>     simulate GC bias, 0:no, 1:yes, default:"<<InputParameter.Is_simulate_GC_bias<<endl;
	cout<<"\t-q  <int>     simulate quality value, 0:no(fasta), 1:yes(fastq), default:"<<InputParameter.Is_simulate_quality<<endl;
	cout<<"\t-M  <int>     simulate quality value by Quality-transition mode, 0:no, 1:yes, default:"<<InputParameter.Q_Mode<<endl;
	cout<<"\t-Q  <int>     ASCII shift of quality value, generally 64 or 33 for Illumina data, default:"<<InputParameter.Q_shift<<endl;
	cout<<"\t-E  <int>     mode of read-end masking by EAMSS algorithm, 0:none, 1:Quality=2, 2:lowercase Base. default:"<< InputParameter.Mask_quality_mode<<endl;
	cout<<"\t-f  <int>     cyclize insert fragment (influence on PE reads' direction) 0: read1-forward read2-reverse, 1: read1-reverse read2-forward, default:"<<InputParameter.Is_cyclization<<endl;
	cout<<"\t-c  <int>     output file type, 0:text, 1:compressed(*.gz), default:"<<InputParameter.Output_type<<endl;
	cout<<"\t-o  <string>  prefix of output file, default:"<<InputParameter.Output_prefix<<endl;
	cout<<"\t-h            output help infomation."<<endl;
	cout<<endl<<"Example:"<<endl;
	cout<<"\t1. ./pirs simulate -i ref_sequence.fa"<<endl;
	cout<<"\t  Every parameter use the default value."<<endl;
	cout<<"\t2. ./pirs simulate -i ref_sequence.fa -l 100 -x 20 -o human_500_100"<<endl;
	cout<<"\t  Just set read length and coverage you needed."<<endl;
	cout<<"\t3. ./pirs simulate -i ref_sequence.fa -o human -m 600 -v 30"<<endl;
	cout<<"\t  Set insertsize distribution."<<endl;
	cout<<"\t4. ./pirs simulate -i ref_sequence.fa -I ref_seq.snp.indel.inversion.fa.gz -o human "<<endl;
	cout<<"\t  The genome is diploid and you want to produce heterozygosis SNPs  heterozygosis Indels in reads, "<<endl;
	cout<<"\t  the -I input file was generated by command \"pirs diploid\"."<<endl;
	cout<<"\t5. ./pirs simulate -i ref_sequence.fa -g 0 -m 2000 -f 1 -c 0 -o human "<<endl;
	cout<<"\t  simulate no GCbias, cyclize the large insert-size library, output file is text format."<<endl;
	cout<<"\t6. ./pirs simulate -i ref_sequence.fa -q 0 -o human "<<endl;
	cout<<"\t  simulate fasta file, the ouput is in *.fa format."<<endl;
	cout<<"\t7. ./pirs simulate -i ref_sequence.fa -a 0 -l 75 -o human "<<endl;
	cout<<"\t  simulate no InDel-error."<<endl;
	cout<<"\t8. ./pirs simulate -i ref_sequence.fa -e 0.01"<<endl;
	cout<<"\t  average substitution-error rate is 1%."<<endl;
	exit(-1);
}

void SimReads_Getopt(int argc,char *argv[]){
	int c;
	while ((c=getopt(argc,argv,"i:I:s:d:b:l:x:m:v:e:a:f:g:q:M:Q:E:c:o:h"))!=-1)
	{
		switch(c){
			case 'i': InputParameter.Input_ref1=optarg;break;
			case 'I': InputParameter.Input_ref2=optarg;break;
			case 's': InputParameter.BaseCalling_profile=optarg;break;
			case 'd': InputParameter.GC_depth_profile=optarg;break;
			case 'b': InputParameter.InDel_error_profile=optarg;break;
			case 'l': InputParameter.Read_length=atoi(optarg);break;
			case 'x': InputParameter.Coverage=atof(optarg);break;
			case 'm': InputParameter.Insertsize_mean=atoi(optarg);break;
			case 'v': InputParameter.Insertsize_sd=atoi(optarg);break;
			case 'e': InputParameter.Error_rate=atof(optarg);break;
			case 'a': InputParameter.Is_simulate_InDel=atoi(optarg);break;
			case 'f': InputParameter.Is_cyclization=atoi(optarg);break;
			case 'g': InputParameter.Is_simulate_GC_bias=atoi(optarg);break;
			case 'q': InputParameter.Is_simulate_quality=atoi(optarg);break;
			case 'M': InputParameter.Q_Mode=atoi(optarg);break;
			case 'Q': InputParameter.Q_shift=atoi(optarg);break;
			case 'E': InputParameter.Mask_quality_mode=atoi(optarg);break;
			case 'c': InputParameter.Output_type=atoi(optarg);break;
			case 'o': InputParameter.Output_prefix=optarg;break;
			case 'h': SimReads_Usage();break;
			default: SimReads_Usage();
		}
	}
}

int simulate_Illumina_reads(int argc, char *argv[])
{
	time_t time_start, time_end;
	time_start = time(NULL);
	srand((unsigned)time(NULL));
	
	if (argc==1)
	{
		SimReads_Usage();
	}
	
	SimReads_Getopt(argc,argv);
	
	argv--;
	
	//set insertsize sd default value
	if(InputParameter.Insertsize_sd == -1){InputParameter.Insertsize_sd = int(InputParameter.Insertsize_mean/20);}
	//check parameter
	if(InputParameter.Input_ref1 == ""){cerr<<"Error: there is not default value with option -i, please input reference sequence!"<<endl;exit(-1);}
	if(InputParameter.Read_length <= 0){cerr<<"Error: read length should be set bigger than 0, please check option -l !"<<endl;exit(-1);}
	if(InputParameter.Coverage <= 0){cerr<<"Error: coverage should be set bigger than 0, please check option -x !"<<endl;exit(-1);}
	if(InputParameter.Insertsize_mean < InputParameter.Read_length){cerr<<"Error: insertize mean should be set bigger than read_length, please check option -m !"<<endl;exit(-1);}
	if(InputParameter.Insertsize_sd < 0){cerr<<"Error: insertsize_sd should be set bigger than 0, please check option -v !"<<endl;exit(-1);}
	if(InputParameter.Error_rate != -1 && InputParameter.Error_rate != 0 && InputParameter.Error_rate < 0.0001 || InputParameter.Error_rate > 0.63 ){cerr<<"Error: error_rate should be set 0 or between 0.0001 and 0.63, you can also set -1 to simulate default error rate according with error profile, please check option -e !"<<endl;exit(-1);}
	if(InputParameter.Is_cyclization != 0 && InputParameter.Is_cyclization != 1){cerr<<"Error: Is_cyclization should be set 0 or 1, please check option -f !"<<endl;exit(-1);}
	if(InputParameter.Is_simulate_GC_bias != 0 && InputParameter.Is_simulate_GC_bias != 1){cerr<<"Error: Is_simulate_GC_bias should be set 0 or 1, please check option -g !"<<endl;exit(-1);}
	if(InputParameter.Is_simulate_quality != 0 && InputParameter.Is_simulate_quality != 1){cerr<<"Error: Is_simulate_quality should be set 0 or 1, please check option -q !"<<endl;exit(-1);}
	if(InputParameter.Is_simulate_InDel != 0 && InputParameter.Is_simulate_InDel != 1){cerr<<"Error: Is_simulate_InDel should be set 0 or 1, please check option -a !"<<endl;exit(-1);}
	if(InputParameter.Q_Mode != 0 && InputParameter.Q_Mode != 1){cerr<<"Error: Q_Mode should be set 0 or 1, please check option -M !"<<endl;exit(-1);}
	if(InputParameter.Mask_quality_mode != 0 && InputParameter.Mask_quality_mode != 1 && InputParameter.Mask_quality_mode != 2){cerr<<"Error: Mask_quality_mode should be set 0 , 1 or 2, please check option -E !"<<endl;exit(-1);}
	if(InputParameter.Output_type != 0 && InputParameter.Output_type != 1){cerr<<"Error: output_type should be set 0 or 1, please check option -c !"<<endl;exit(-1);}

	//set the simulate cycle number
	Simulate_Cycle_num = InputParameter.Read_length*2;
	//initialize error position distribution table
	Error_pos_distr = new uint64_t[Simulate_Cycle_num+1];
	Q_to_Erate_distr = new double[Simulate_Cycle_num+1];
	for(int i=0; i<=Simulate_Cycle_num; i++)
	{
		Error_pos_distr[i] = 0;
		Q_to_Erate_distr[i] = 0.0;
	}
	
	//input file
	igzstream infile; 
	igzstream infile2;
	//output file
	ofstream insert_log;
	ofstream error_log;
	//check and open file
	set_and_check_file( InputParameter, infile, infile2, Outfile1,	Outfile2, Gz_outfile1, Gz_outfile2, insert_log, error_log, Infor_outfile);
	
	
	////////////////////Load Base-calling profile///////////////////////
	
	string exe_path = argv[0]; //program package path
	
	cerr<<"Start to preview error profile..."<<endl;
	//get dimensions of error profile  
	
	preview_BaseCalling_profile (InputParameter, exe_path, Ref_Base_num, Statistical_Cycle_num, Seq_Base_num, Quality_num, Statistical_average_error_rate);
  cout << "In Base-calling profile:"<<endl
  	<< "\tRef_Base_num: " << Ref_Base_num << endl
  	<< "\tStatistical_Cycle_num: " << Statistical_Cycle_num << endl
  	<< "\tSeq_Base_num: " << Seq_Base_num << endl
  	<< "\tQuality_num: " << Quality_num << endl
  	<< "\t"<<InputParameter.Read_length<<"bp reads total average substitution error rate: "<< Statistical_average_error_rate <<endl;
	
	//transform quality score according error-rate setting by user.
	Qval2Qval = new int[Quality_num];
	for(int i = 0; i < Quality_num; i++)
	{
		Qval2Qval[i] = 0;
	}
	if(InputParameter.Error_rate != -1)
	{
		transform_quality_by_error_rate(InputParameter, exe_path, Qval2Qval, Seq_Base_num, Quality_num, Statistical_Cycle_num);
	}
	
	//initialize simulation matrix
	if(InputParameter.Q_Mode == 1){ 
  	//initialize matrix table  Ref_Base_num*Simulate_Cycle_num*Seq_Base_num*Quality_num
  	First_cycle_matrix = new double**[Ref_Base_num];
  	for(int i=0; i<Ref_Base_num; i++)
  	{
  		First_cycle_matrix[i] = new double*[2];
  		for(int j=0; j<2; j++)
  		{
  			First_cycle_matrix[i][j] = new double[Seq_Base_num*Quality_num];
  			for(int k=0; k<Seq_Base_num*Quality_num; k++)
  			{
  				First_cycle_matrix[i][j][k] = 0;
  			}
  		}
  	}
  	
		Simulation_matrix1 = new double**[Simulate_Cycle_num];
		for(int i=0; i<Simulate_Cycle_num; i++)
		{
			Simulation_matrix1[i] = new double*[Quality_num];
			for(int j=0; j<Quality_num; j++)
			{
  			Simulation_matrix1[i][j] = new double[Quality_num];
  			for(int k=0; k<Quality_num; k++)
  			{
  				Simulation_matrix1[i][j][k] = 0;
  			}
			}
		}
  	
  }else{
		Simulation_matrix1 = new double**[Ref_Base_num];
		for(int i=0; i<Ref_Base_num; i++)
		{
			Simulation_matrix1[i] = new double*[Simulate_Cycle_num];
			for(int j=0; j<Simulate_Cycle_num; j++)
			{
  			Simulation_matrix1[i][j] = new double[Quality_num];
  			for(int k=0; k<Quality_num; k++)
  			{
  				Simulation_matrix1[i][j][k] = 0;
  			}
			}
		}
  }
  
	Simulation_matrix2 = new double***[Ref_Base_num];
	for(int i=0; i<Ref_Base_num; i++)
	{
		Simulation_matrix2[i] = new double**[Simulate_Cycle_num];
		for(int j=0; j<Simulate_Cycle_num; j++)
		{
			Simulation_matrix2[i][j] = new double*[Quality_num];
			for(int k=0; k<Quality_num; k++)
			{
				Simulation_matrix2[i][j][k] = new double[Seq_Base_num];
				for(int l=0; l<Seq_Base_num; l++)
				{
					Simulation_matrix2[i][j][k][l] = 0;
				}
			}
		}
	}
	
	string base_calling_profile = "none";
	//get the simulation matrix
	if(InputParameter.Q_Mode == 1){
		base_calling_profile = load_BaseCalling_profile1(InputParameter, exe_path, Statistical_Cycle_num, Seq_Base_num, Quality_num, Statistical_average_error_rate, Simulation_matrix1);
		base_calling_profile = load_BaseCalling_profile2(InputParameter, exe_path, Statistical_Cycle_num, Seq_Base_num, Quality_num, Statistical_average_error_rate, Simulation_matrix2, First_cycle_matrix);
	}else{
		base_calling_profile = load_BaseCalling_profile3(InputParameter, exe_path, Statistical_Cycle_num, Seq_Base_num, Quality_num, Statistical_average_error_rate, Simulation_matrix1, Simulation_matrix2);
	}
	///////////////////////////load GC bias profile///////////////////////////////
	
	//get GC abundance for simulate GC bias
	string gc_bias_profile = "none";
	if(InputParameter.Is_simulate_GC_bias){
		GC_bias_abundance = new double[101];
		for(int i = 0; i <= 100; i++)
		{
			GC_bias_abundance[i] = 0.0;
		}
		gc_bias_profile = load_GC_depth_profile (InputParameter, exe_path, GC_bias_abundance);
	}
	
	////////////////////////////load InDel-error profile///////////////////////////

	string indel_error_profile = "none";
	if(InputParameter.Is_simulate_InDel)
	{
		uint64_t Read1_count = 0;
		uint64_t Read2_count = 0;
		preview_InDel_error_profile (InputParameter, exe_path, Statistical_Cycle_num2, InDel_max_len, Read1_count, Read2_count);
		if(Statistical_Cycle_num2 == 0 || InDel_max_len == 0)
		{
			cerr<<"Warning: can not get the InDel-error profile information, so program not to simualte InDel-error, please check profile is in the right format!"<<endl;
			InputParameter.Is_simulate_InDel = 0;
		}else{
			InDel_error_matrix =  new double*[Statistical_Cycle_num2];
			for(int i = 0; i < Statistical_Cycle_num2; i++)
			{
				InDel_error_matrix[i] = new double[InDel_max_len*2+1];  // -3 -2 -1 0 1 2 3
				for(int j = 0; j < InDel_max_len*2+1; j++)
				{
					InDel_error_matrix[i][j] = 0;
				}
			}
			InDel_num = new int[InDel_max_len*2+1];
			for(int i =0; i < InDel_max_len*2+1; i++)
			{
				InDel_num[i] =  InDel_max_len +  (i - InDel_max_len*2); //0(-3) 1(-2) 2(-1) 3(0) 4(1) 5(2) 6(3)
			}
			indel_error_profile = load_InDel_error_profile(InputParameter, exe_path, Statistical_Cycle_num2, InDel_max_len, Read1_count, Read2_count, InDel_num, InDel_error_matrix);
		}
	}
	
	//////////////////////////output input parameter information///////////////////

	string ref2_info = InputParameter.Input_ref2;
	if(InputParameter.Input_ref2.empty())
	{
		ref2_info = "none, just simulate reads from haploid." ;
	}
	string Is_cyc = "yes";
	if(InputParameter.Is_cyclization == 0)
	{
		Is_cyc = "no";
	}
	string Is_simGC = "yes";
	if(InputParameter.Is_simulate_GC_bias == 0)
	{
		Is_simGC = "no";
	}
	string Is_Indel = "yes";
	if(InputParameter.Is_simulate_InDel == 0)
	{
		Is_Indel = "no";
	}
	string Is_simQual = "no";
	if(InputParameter.Is_simulate_quality)
	{
		Is_simQual = "yes";
	}
	string Is_qt = "yes";
	if(InputParameter.Q_Mode == 0)
	{
		Is_qt = "no";
	}
	string mode_of_Mask = "none";
	if(InputParameter.Mask_quality_mode == 1)
	{
		mode_of_Mask = "Quality = 2";
	}else if(InputParameter.Mask_quality_mode == 2)
	{
		mode_of_Mask = "Lowercase Base";
	}
	string outtype = "compressed(*.gz)";
	if(InputParameter.Output_type == 0)
	{
		outtype = "text";
	}
	double input_error_rate = 0;
	if(InputParameter.Error_rate == -1)
	{
		input_error_rate = Statistical_average_error_rate;
	}else{
		input_error_rate = InputParameter.Error_rate;
	}
	
	
	Infor_outfile<<"#input reference1: "<<InputParameter.Input_ref1<<endl
		<<"#input reference2: "<<ref2_info<<endl
		<<"#base-Calling profile: "<<base_calling_profile<<endl
		<<"#simulate GC content-coverage bias: "<<Is_simGC<<endl
		<<"#GC content-coverage profile: "<<gc_bias_profile<<endl
		<<"#simulate InDel-error in reads: "<<Is_Indel<<endl
		<<"#InDel-error profile: "<<indel_error_profile<<endl
		<<"#read length: "<<InputParameter.Read_length<<endl
		<<"#data coverage: "<<InputParameter.Coverage<<endl
		<<"#substitution-error rate setting by user: "<<input_error_rate<<" (you can find the real substitution-error rate of output data in file *.error_rate.distr)"<<endl
		<<"#mean of insertsize: "<<InputParameter.Insertsize_mean<<endl
		<<"#standard deviation of insert sizes: "<<InputParameter.Insertsize_sd<<endl
		<<"#cyclization: "<<Is_cyc<<endl
		<<"#reads file output type: "<<outtype<<endl
		<<"#output prefix: "<<InputParameter.Output_prefix<<endl
		<<"#simulate quality value: "<<Is_simQual<<endl;
		
	if(InputParameter.Is_simulate_quality == 1)
	{
		Infor_outfile<<"#simulate quality value by Quality-transition mode: "<< Is_qt<<endl
			<<"#ASCII shift of quality value: "<<InputParameter.Q_shift<<endl
			<<"#mode of mask quality: "<<mode_of_Mask<<endl;
	}

	Infor_outfile<<endl<<"#readId\t-i/-I\tchr\tposition\t+/-\tinsertSize\tmaskEndLen\tsubstitution\tinsertion\tdeletion"<<endl;
	
	///////////////////////////get genome seq and start to simulate reads/////////////////////////////
	
	//start simulation
	Get_genome(infile,infile2);
	
	
	/////////////////////////output error distribution and insert size distribution////////////////////////////

	//ouput error position distribution
	error_log<<"**********Error rate distribution**********"<<endl;
	if(InputParameter.Is_simulate_quality){
		double real_error_num = 0;
		double qto_error_num = 0;
		error_log<<"Cycle\tReal_error_rate\tQuality_to_error_rate"<<endl;
  	for(int i=1; i<=Simulate_Cycle_num; i++){
  		error_log<<i<<"\t"<<double(Error_pos_distr[i])/double(Total_read_pair)<<"\t"<<Q_to_Erate_distr[i]/double(Total_read_pair)<<endl;
  		real_error_num += double(Error_pos_distr[i])/double(Total_read_pair);
  		qto_error_num += Q_to_Erate_distr[i]/double(Total_read_pair);
  		if(i== InputParameter.Read_length){error_log<<endl;}
  	}
  	error_log<<endl
  		<<"total:\t"<<real_error_num/double(Simulate_Cycle_num)<<"\t"<<qto_error_num/double(Simulate_Cycle_num)<<endl;
	}else{
		double real_error_num = 0;
		error_log<<"Cycle\tReal_error_rate"<<endl;
  	for(int i=1; i<=Simulate_Cycle_num; i++){
  		error_log<<i<<"\t"<<double(Error_pos_distr[i])/double(Total_read_pair)<<endl;
  		real_error_num += double(Error_pos_distr[i])/double(Total_read_pair);
  		if(i== InputParameter.Read_length){error_log<<endl;}
  	}
  	error_log<<endl
  		<<"total:\t"<<real_error_num/double(Simulate_Cycle_num)<<endl;
	}
	delete[] Error_pos_distr;
	delete[] Q_to_Erate_distr;
	
	//output insert size distribution
	insert_log<<"**********Insert size distribution************"<<endl
		<<"insert_size_len"<<"\t"<<"number"<<endl;
	map<int, uint64_t>::const_iterator map_it = InsertSize_distr.begin();
	while (map_it != InsertSize_distr.end())
	{
		insert_log<<map_it->first<<"\t"<<map_it->second<<endl;
		map_it++;
	}
	
	if(InputParameter.Is_simulate_GC_bias)
	{
		delete[] GC_bias_abundance;
	}
	
  for(int i=0; i<Ref_Base_num; i++)
  {
  	for(int j=0; j<Simulate_Cycle_num; j++)
  	{
  		for(int k=0; k<Quality_num; k++)
  		{
  			delete[] Simulation_matrix2[i][j][k];
  		}
  		delete[] Simulation_matrix2[i][j];
  	}
  	delete[] Simulation_matrix2[i];
  }
  delete[] Simulation_matrix2;
	
	if(InputParameter.Q_Mode == 1){
    
  	for(int j=0; j<Simulate_Cycle_num; j++)
  	{
  		for(int k=0; k<Quality_num; k++)
  		{
  			delete[] Simulation_matrix1[j][k];
  		}
  		delete[] Simulation_matrix1[j];
  	}
  	delete[] Simulation_matrix1;
  	
  	for(int i=0; i<Ref_Base_num; i++)
  	{
  		for(int j=0; j<2; j++)
  		{
  			delete[] First_cycle_matrix[i][j];
  		}
  		delete[] First_cycle_matrix[i];
  	}
  	delete[] First_cycle_matrix;
  	
	}else{
		
  	for(int j=0; j<Ref_Base_num; j++)
  	{
  		for(int k=0; k<Simulate_Cycle_num; k++)
  		{
  			delete[] Simulation_matrix1[j][k];
  		}
  		delete[] Simulation_matrix1[j];
  	}
  	delete[] Simulation_matrix1;
		
	}
	
	if(InputParameter.Is_simulate_InDel)
	{
		for(int i = 0; i < Statistical_Cycle_num2; i++)
		{
			delete[] InDel_error_matrix[i];
		}
		delete[] InDel_error_matrix;
		
		delete[] InDel_num;
	}
	
	delete[] Qval2Qval;

	infile.close();
	if(InputParameter.Input_ref2 != ""){infile2.close();}
	insert_log.close();
	error_log.close();
	if(InputParameter.Output_type == 1){
		Gz_outfile1.close();
		Gz_outfile2.close();
	}else{
		Outfile1.close();
		Outfile2.close();
	}
	
	Infor_outfile.close();
	
  cout<<"\nIn ouput data:"<<endl
  	<<"\tsum of Insertion in read1 file: "<<Read1_ins_sum<<endl
  	<<"\tsum of Deletion in read1 file: "<<Read1_del_sum<<endl
  	<<"\tsum of Insertion in read2 file: "<<Read2_ins_sum<<endl
  	<<"\tsum of Deletion in read2 file: "<<Read2_del_sum<<endl;
	
	time_end = time(NULL);
	cerr<<"All done! Run time: "<<time_end-time_start<<"s."<<endl;
	
	return 0;
}

//get genome sequence and start to simulate read 
void Get_genome(igzstream &inf,igzstream &inf2){
	string line,line2,id,id_line,seq,seq2;
	uint64_t readINgenome=0;

	while (getline(inf,line,'\n'))
	{
		if (line[0]=='>')
		{
			if (seq!="")
			{	
				//another diploid seq
				if(InputParameter.Input_ref2 != ""){
					while(getline(inf2,line2,'\n'))
					{
						if(line2[0] == '>')
						{
							if(seq2!="")
							{
        				cerr<<"Have finished reading scaffold "<<id<<endl;
        				readINgenome+=contral_reads_quantity(id_line,id,seq,seq2,readINgenome);
        				seq="";
        				seq2="";
        				break;
							}
						}else{
							seq2+=line2;
						}
					}
				}else{
					cerr<<"Have finished reading scaffold "<<id<<endl;

					readINgenome+=contral_reads_quantity(id_line,id,seq,seq2,readINgenome);
					seq="";
				}
			}
			id_line = line;
			line.erase(0,1);
			int pos=line.find(" ");
			line=line.substr(0,pos);
			id=line;
		}else{
			seq+=line;
		}		
	}
	cerr<<"Have finished reading scaffold "<<id<<endl;
	if(InputParameter.Input_ref2 != ""){
		while(getline(inf2,line2,'\n'))
		{
			if(line2[0] == '>'){continue;}
			seq2+=line2;
		}
	}
	readINgenome+=contral_reads_quantity(id_line,id,seq,seq2,readINgenome);
}

//contral the quantity of simulate reads for each chromosome one by one
uint64_t contral_reads_quantity(string id_line,string id,string &sequence,string &sequence2,uint64_t read_genome)
{
	uint64_t readonchr=0;
	if (sequence.size()<InputParameter.Insertsize_mean)
	{
		return 0;
	}
	//convert lower case to upper case 
	to_upper(sequence);

	uint64_t sequence_length=sequence.size();
	uint64_t reads_pair_num=0;
	
	if (InputParameter.Input_ref2 != "")
	{
		reads_pair_num=(uint64_t)(sequence_length*InputParameter.Coverage/InputParameter.Read_length/2/2);
	}else{
		reads_pair_num=(uint64_t)(sequence_length*InputParameter.Coverage/InputParameter.Read_length/2);
	}
	Total_read_pair = Total_read_pair + (uint64_t)(sequence_length*InputParameter.Coverage/InputParameter.Read_length/2);
	
	readonchr = simulate_reads(sequence,sequence_length,reads_pair_num, id, 1, read_genome);

	//simulate reads of another diploid genome 
	if (InputParameter.Input_ref2 != "") 
	{
		sequence_length=sequence2.size();
		if (sequence_length<InputParameter.Insertsize_mean)
		{
			return 0;
		}
		reads_pair_num=(uint64_t)(sequence_length*InputParameter.Coverage/InputParameter.Read_length/2/2);

		uint64_t readonchr2=read_genome+readonchr;
		
		readonchr += simulate_reads(sequence2,sequence_length,reads_pair_num, id, 2, readonchr2);
	}
	return readonchr;
}


uint64_t simulate_reads(string &seq,uint64_t seqlen, uint64_t rd_pair, string id_seq, int i_or_I, uint64_t reads_all)
{
	int whether_check_seq = 0; 
	if(!check_seq(seq)){
		whether_check_seq = 1;
	}
	
	string id_header = ">";
	if(InputParameter.Is_simulate_quality)
	{
		id_header = "@";
	}
	
	uint64_t reads_count=0;
	cerr<<"Begin to output reads..."<<endl;
	for(uint64_t pair_count=0; pair_count < rd_pair; pair_count++)
	{
		//simulate insertsize
		int insertsize = simulate_insertsize(InputParameter.Insertsize_mean,InputParameter.Insertsize_sd);
		if (insertsize<InputParameter.Read_length){pair_count--;continue;}
		if (seqlen<insertsize){return reads_count;}
		uint64_t N = 1000000000000;
		uint64_t pos = (uint64_t)(((uint64_t)((double)rand() / double(RAND_MAX) * N)) % seqlen);
		if (pos+insertsize>seqlen){pair_count--;continue;}
			
		//get insert seq
		string sub_str=seq.substr(pos,insertsize);

		map<int,string,less<int> > indel1;
		map<int,string,less<int> > indel2;
		int r1_slen = 0;
		int r2_slen = 0; 
		if(InputParameter.Is_simulate_InDel)
		{
			get_reads_indel(InputParameter.Read_length, indel1, indel2, r1_slen, r2_slen, InDel_max_len, InDel_error_matrix, InDel_num);
		}
		
		string ref_read1, ref_read2;
		int selection=int(rand()%2); //0 or 1, for selecting output file randomly and deciding read +/-
		
		int read1_pos, read2_pos;
		if(selection == 0)
		{
			ref_read1 = sub_str.substr(0, InputParameter.Read_length-r1_slen);
			ref_read2 = sub_str.substr(insertsize-InputParameter.Read_length+r2_slen, InputParameter.Read_length-r2_slen);
			read1_pos = pos+1;
			read2_pos = pos+insertsize-InputParameter.Read_length-r2_slen+1;
		}else{
			ref_read1 = sub_str.substr(insertsize-InputParameter.Read_length+r1_slen, InputParameter.Read_length-r1_slen);
			ref_read2 = sub_str.substr(0, InputParameter.Read_length-r2_slen);
			read1_pos = pos+insertsize-InputParameter.Read_length-r1_slen+1;		
			read2_pos = pos+1;		
		}
		
		//check whether contain 'N' or nonbase char
		if(whether_check_seq && (!check_seq(ref_read1) || !check_seq(ref_read2))){
			pair_count--;
			continue;
		}
		
		//simulate GC bias
		if(InputParameter.Is_simulate_GC_bias){
			string check_seq = ref_read1+ref_read2;
			if(simulate_GC_bias(check_seq,GC_bias_abundance)){pair_count--;continue;}
		}
		
		//insertsize statistics
		if(InsertSize_distr[insertsize]>0)
		{
			InsertSize_distr[insertsize]++;
		}else{
			InsertSize_distr[insertsize] = 1;
		}
		
		reads_count++;
		
		string read1_order, read2_order;
		if ( InputParameter.Is_cyclization == 1 )
		{
			if(selection == 0){
				ref_read1=reversecomplementary(ref_read1);
				read1_order = "-";
				read2_order = "+";
			}else{
				ref_read2=reversecomplementary(ref_read2);
				read1_order = "+";
				read2_order = "-";
			}

		}else if (InputParameter.Insertsize_mean>0)
		{
			if(selection == 0){
				ref_read2=reversecomplementary(ref_read2);
				read1_order = "+";
				read2_order = "-";
									
			}else{
				ref_read1=reversecomplementary(ref_read1);
				read1_order = "-";
				read2_order = "+";				
			}
		}else{
			cout<<"Error:insertsize mean is smaller than 0"<<endl;
			exit(-1);
		}
		
		bool* Is_insertion_pos1;
		bool* Is_insertion_pos2;
		Is_insertion_pos1 = new bool[InputParameter.Read_length];
		Is_insertion_pos2 = new bool[InputParameter.Read_length];
		for(int i =0 ; i < InputParameter.Read_length; i++)
		{
			Is_insertion_pos1[i] = 0;
			Is_insertion_pos2[i] = 0;
		}	
		string read1=ref2read(ref_read1, indel1, Is_insertion_pos1);

		string read2=ref2read(ref_read2, indel2, Is_insertion_pos2);	

		string output_read1, output_read2, output_quality_seq1, output_quality_seq2;
		
		vector<int> error_pos1;
  	vector<char> raw_base1;
  	vector<int> error_pos2;
  	vector<char> raw_base2;
  	
  	//do not use Qtran Matrix for simulation
		if(InputParameter.Q_Mode == 0)
		{
  		//simulate read1
  		for(int i = 0; i < InputParameter.Read_length; i++)
  		{
  			double num=double(rand())/double(RAND_MAX);
  			char ref_base = read1[i];
  			int cycle = i;
  			int Qscore = 0;
  			int output_Qscore = 0;
  			char call_base;
  			
  			if(InputParameter.Error_rate == 0)
  			{
  				call_base = ref_base;
  				output_Qscore = Quality_num - 1;
  			}else{
  				
    			int location = search_location(Simulation_matrix1[alphabet2[ref_base]][cycle], Quality_num, num);
  			
  				if(location == Quality_num){
  					Qscore = Quality_num - 1;
    			} 
    			else{
    				Qscore = location;
    			}
  				if(InputParameter.Error_rate == -1)
  				{
  					double num2=double(rand())/double(RAND_MAX);
  					int location2 = search_location(Simulation_matrix2[alphabet2[ref_base]][cycle][Qscore], Seq_Base_num, num2);
  					if(location2 == Seq_Base_num){
    					call_base = get_base_by_Qscore(ref_base, Qscore);
    				} 
    				else{
    					call_base = Bases[location2];
    				}
  			  	output_Qscore = Qscore;
  			  }else{
    			  output_Qscore = Qval2Qval[Qscore];
    			  double num3=double(rand())/double(RAND_MAX);
    			  int location3 = search_location(Simulation_matrix2[alphabet2[ref_base]][cycle][output_Qscore], Seq_Base_num, num3);
    				if(location3 == Seq_Base_num){
    					call_base = get_base_by_Qscore(ref_base, output_Qscore);
      			} 
      			else{
      				call_base = Bases[location3];
      			}
    			}
    			if(ref_base != call_base){
    				if(Is_insertion_pos1[i]){  //insertion not to simulate substitution error
    					call_base = ref_base;
    				}else{
    					Error_pos_distr[i+1]++;
    					error_pos1.push_back(i);
    					raw_base1.push_back(ref_base);
    				}
    			}
  			}

  			output_read1.push_back(call_base);
  			char quality_value = output_Qscore + InputParameter.Q_shift;  
  			output_quality_seq1.push_back(quality_value);
  		}
  		
  		//simulate read2
  		for(int i = 0; i < InputParameter.Read_length; i++)
  		{
  			double num=double(rand())/double(RAND_MAX);
  			char ref_base = read2[i];
  			int cycle = i+Simulate_Cycle_num/2;	
  			int Qscore = 0;
  			int output_Qscore = 0;
  			char call_base;
  			
  			if(InputParameter.Error_rate == 0)
  			{
  				call_base = ref_base;
  				output_Qscore = Quality_num - 1;
  			}else{
  				
    			int location = search_location(Simulation_matrix1[alphabet2[ref_base]][cycle], Quality_num, num);
    			
  				if(location == Quality_num){
  					Qscore = Quality_num - 1;
    			} 
    			else{
    				Qscore = location;
    			}
  				if(InputParameter.Error_rate == -1)
  				{
  					double num2=double(rand())/double(RAND_MAX);
  					int location2 = search_location(Simulation_matrix2[alphabet2[ref_base]][cycle][Qscore], Seq_Base_num, num2);
  					if(location2 == Seq_Base_num){
    					call_base = get_base_by_Qscore(ref_base, Qscore);
    				} 
    				else{
    					call_base = Bases[location2];
    				}
  			  	output_Qscore = Qscore;
  			  }else{
    			  output_Qscore = Qval2Qval[Qscore];
    			  double num3=double(rand())/double(RAND_MAX);
    			  int location3 = search_location(Simulation_matrix2[alphabet2[ref_base]][cycle][output_Qscore], Seq_Base_num, num3);
    				if(location3 == Seq_Base_num){
    					call_base = get_base_by_Qscore(ref_base, output_Qscore);
      			} 
      			else{
      				call_base = Bases[location3];
      			}
    			}
    			if(ref_base != call_base){
    				if(Is_insertion_pos2[i])
    				{
    					call_base=ref_base;
    				}else{
    					Error_pos_distr[i+1+InputParameter.Read_length]++;
    					error_pos2.push_back(i);
    					raw_base2.push_back(ref_base);
    				}
    			}
  			}

  			output_read2.push_back(call_base);
  			char quality_value = output_Qscore + InputParameter.Q_shift;  
  			output_quality_seq2.push_back(quality_value);
  		}
  		
		}else{ //use Qtran Matrix for simulation
  		//simulate read1
  		
  		int pre_Q = 0;
  		for(int i = 0; i < InputParameter.Read_length; i++)
  		{
  			double num=double(rand())/double(RAND_MAX);
  			double num2=double(rand())/double(RAND_MAX);
  			
  			char ref_base = read1[i];
  			int cycle;
  			cycle = i;
  			char call_base;
  			int Qscore;
  			int output_Qscore;
  			int location = 0;
  			int location2 = 0;
  			
  			if(InputParameter.Error_rate == 0)
  			{
  				call_base = ref_base;
  				output_Qscore = Quality_num - 1;
  			}else{
  			
    			if(cycle == 0){
    				
    				location = search_location(First_cycle_matrix[alphabet2[ref_base]][0], Seq_Base_num*Quality_num, num);
  			
    				if(location == Seq_Base_num*Quality_num){
    					call_base = ref_base;
    					Qscore = Quality_num - 1;
      			} 
      			else{
      				int call_base_num = int(location/Quality_num);
      				Qscore = location%Quality_num;
      				if(InputParameter.Error_rate == -1)
      				{
      			  	call_base = Bases[call_base_num];
      			  	output_Qscore = Qscore;
      			  }else{
        			  output_Qscore = Qval2Qval[Qscore];
        			  double num3=double(rand())/double(RAND_MAX);
        			  int location3 = search_location(Simulation_matrix2[alphabet2[ref_base]][cycle][output_Qscore], Seq_Base_num, num3);
        				if(location3 == Seq_Base_num){
        					call_base = get_base_by_Qscore(ref_base, output_Qscore);
          			} 
          			else{
          				call_base = Bases[location3];
          			}
        			}
      			}
    				
    			}else{
    				int location = search_location(Simulation_matrix1[cycle][pre_Q], Quality_num, num);
    				
    				if(location == Quality_num){
    					Qscore = pre_Q;
      			} 
      			else{
      				Qscore = location;
      			}
    				if(InputParameter.Error_rate == -1)
    				{
    					int location2 = search_location(Simulation_matrix2[alphabet2[ref_base]][cycle][Qscore], Seq_Base_num, num2);
    					if(location2 == Seq_Base_num){
      					call_base = get_base_by_Qscore(ref_base, Qscore);
      				} 
      				else{
      					call_base = Bases[location2];
      				}
    			  	output_Qscore = Qscore;
    			  }else{
      			  output_Qscore = Qval2Qval[Qscore];
      			  double num3=double(rand())/double(RAND_MAX);
      			  int location3 = search_location(Simulation_matrix2[alphabet2[ref_base]][cycle][output_Qscore], Seq_Base_num, num3);
      				if(location3 == Seq_Base_num){
      					call_base = get_base_by_Qscore(ref_base, output_Qscore);
        			} 
        			else{
        				call_base = Bases[location3];
        			}
      			}
    			}
    			
    			pre_Q = Qscore;
  			
    			if(ref_base != call_base){
    				if(Is_insertion_pos1[i]){
    					call_base = ref_base;
    				}else{
    					Error_pos_distr[i+1]++;
      				error_pos1.push_back(i);
      				raw_base1.push_back(ref_base);
    				}
    			}
  			}
  			output_read1.push_back(call_base);
  			
  			char quality_value = output_Qscore + InputParameter.Q_shift;  
  			output_quality_seq1.push_back(quality_value);
  		}
  		
  		//simulate read2
  		pre_Q = 0;
  		for(int i = 0; i < InputParameter.Read_length; i++)
  		{
  			double num=double(rand())/double(RAND_MAX);
  			double num2=double(rand())/double(RAND_MAX);
  			char ref_base = read2[i];
  			int cycle;
  			cycle = i+Simulate_Cycle_num/2;

  			char call_base;
  			int Qscore;
  			int output_Qscore;
  			int location = 0;
  			int location2 = 0;
  			
  			if(InputParameter.Error_rate == 0)
  			{
  				call_base = ref_base;
  				output_Qscore = Quality_num - 1;
  			}else{
  				
    			if(cycle == Simulate_Cycle_num/2){
    				location = search_location(First_cycle_matrix[alphabet2[ref_base]][1], Seq_Base_num*Quality_num, num);
    				if(location == Seq_Base_num*Quality_num){
    					call_base = ref_base;
    					Qscore = Quality_num-1;
      			} 
      			else{
      				int call_base_num = int(location/Quality_num);
      			  Qscore = location%Quality_num;
      			  
      				if(InputParameter.Error_rate == -1)
      				{
      			  	call_base = Bases[call_base_num];
      			  	output_Qscore = Qscore;
      			  }else{
        			  output_Qscore = Qval2Qval[Qscore];
        			  double num3=double(rand())/double(RAND_MAX);
        			  int location3 = search_location(Simulation_matrix2[alphabet2[ref_base]][cycle][output_Qscore], Seq_Base_num, num3);
        				if(location3 == Seq_Base_num){
        					call_base = get_base_by_Qscore(ref_base, output_Qscore);
          			} 
          			else{
          				call_base = Bases[location3];
          			}
        			}
      			}
    			}else{
    				int location = search_location(Simulation_matrix1[cycle][pre_Q], Quality_num, num);
    				
    				if(location == Quality_num){
    					Qscore = pre_Q;
      			} //
      			else{
      				Qscore = location;
      			}
      			
    				if(InputParameter.Error_rate == -1)
    				{
    					int location2 = search_location(Simulation_matrix2[alphabet2[ref_base]][cycle][Qscore], Seq_Base_num, num2);
    					if(location2 == Seq_Base_num){
    						call_base = get_base_by_Qscore(ref_base, Qscore);
      				} 
      				else{
      					call_base = Bases[location2];
      				}
    			  	output_Qscore = Qscore;
    			  }else{
      			  output_Qscore = Qval2Qval[Qscore];
      			  double num3=double(rand())/double(RAND_MAX);
      			  int location3 = search_location(Simulation_matrix2[alphabet2[ref_base]][cycle][output_Qscore], Seq_Base_num, num3);
      				if(location3 == Seq_Base_num){
      					call_base = get_base_by_Qscore(ref_base, output_Qscore);
        			} 
        			else{
        				call_base = Bases[location3];
        			}
      			}
    			}
    			pre_Q = Qscore;
    			if(ref_base != call_base){
    				if(Is_insertion_pos2[i]){
    					call_base = ref_base;
    				}else{
    					Error_pos_distr[i+1+InputParameter.Read_length]++;
    					error_pos2.push_back(i);
    					raw_base2.push_back(ref_base);
    				}
    			}
  			}
  			output_read2.push_back(call_base);
  
  			char quality_value = output_Qscore + InputParameter.Q_shift;  
  			output_quality_seq2.push_back(quality_value);
  		}
		}
		int mask_num1 = 0;
  	int mask_num2 = 0;
		if(InputParameter.Is_simulate_quality){
  		//Mask quality using the EAMSS algorithm
  		if(InputParameter.Mask_quality_mode == 1 || InputParameter.Mask_quality_mode == 2)
  		{
  			casava::demultiplex::MaskQvalsByEamss A;
  			A.operator()(output_quality_seq1, output_read1, InputParameter.Mask_quality_mode, InputParameter.Q_shift, mask_num1);
  			A.operator()(output_quality_seq2, output_read2, InputParameter.Mask_quality_mode, InputParameter.Q_shift, mask_num2);
  		}
  		
  		//stat into Q_to_Erate_distr
  		string combine_quality_seq = output_quality_seq1 + output_quality_seq2;
  		for(int i = 0; i < InputParameter.Read_length * 2; i++)
  		{
  			int qval = combine_quality_seq[i] - InputParameter.Q_shift;
  			Q_to_Erate_distr[i + 1] +=  pow(10, double(qval)/double(-10));
  		}
		}
			
		delete[] Is_insertion_pos1;
		delete[] Is_insertion_pos2;
		
		
		//output simulate reads
		if (reads_count%10000==0)
		{
			cerr<<"Output "<<reads_count<<" pair reads"<<endl;
		}
		
		//output read1 information
		//"readId\t-i/-I\tchr\tposition\t+/-\tinsertSize\tmaskEndLen\tsubstitution\tinsertion\tdeletion"
		Infor_outfile<<id_header<<"read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<"\t"<<i_or_I<<"\t"<<id_seq<<"\t"<<read1_pos<<"\t"<<read1_order<<"\t"<<insertsize<<"\t"<<mask_num1<<"\t";
		for(int i = 0; i < error_pos1.size(); i++)
		{
			Infor_outfile<<error_pos1[i]+1<<","<<raw_base1[i]<<"->"<< output_read1[error_pos1[i]] <<";";
		}
		if(error_pos1.size() == 0){
			Infor_outfile<<"-";
		}
		Infor_outfile<<"\t";
		
		if(indel1.size() == 0){
			Infor_outfile<<"-"<<"\t"<<"-";
		}else{
			string inser_inf;
			string delet_inf;
  		int k=0;
  		int j=0;
    	for(size_t i=0; i<ref_read1.size();){
        if(indel1.count(k)==0){
           i++; k++; 
        }
        else if(indel1[k][0]=='-'){
        	int num = k+1;
        	string tem = boost::lexical_cast<string>(num);
        	delet_inf += tem + ",";
        	for(int l=0; l<indel1[k].size(); l++)
        	{
        		delet_inf += ref_read1[i+l];
        	}
        	delet_inf +=";";
          Read1_del_sum+=indel1[k].size();
          i+=indel1[k].size();k++;
          
        }
        else{
        	int num = k+1;
        	string tem = boost::lexical_cast<string>(num);
        		
        		inser_inf += tem + "," + indel1[k] + ";";
            Read1_ins_sum+=indel1[k].size(); 
            k+=indel1[k].size();
           
        }
    	}
    	while(indel1.count(k)>0){
        int num = k+1;
        string tem = boost::lexical_cast<string>(num);
        inser_inf += tem + "," + indel1[k] + ";";
        Read1_ins_sum+=indel1[k].size();
        k+=indel1[k].size();
        
    	}
    	
    	if(inser_inf.empty()){
    		Infor_outfile<<"-"<<"\t";
    	}else{
    		Infor_outfile<<inser_inf<<"\t";
    	}
    	if(delet_inf.empty()){
    		Infor_outfile<<"-";
    	}else{
    		Infor_outfile<<delet_inf;
    	}
  	}
  	
  	Infor_outfile<<endl;
  	
  	//output read2 information
		Infor_outfile<<id_header<<"read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<"\t"<<i_or_I<<"\t"<<id_seq<<"\t"<<read2_pos<<"\t"<<read2_order<<"\t"<<insertsize<<"\t"<<mask_num2<<"\t";
		for(int i = 0; i < error_pos2.size(); i++)
		{
			Infor_outfile<<error_pos2[i]+1<<","<<raw_base2[i]<<"->"<< output_read2[error_pos2[i]] <<";";
		}
		if(error_pos2.size() == 0){
			Infor_outfile<<"-";
		}
		Infor_outfile<<"\t";
		
		if(indel2.size() == 0){
			Infor_outfile<<"-"<<"\t"<<"-";
		}else{
			string inser_inf;
			string delet_inf;
  		int k=0;
  		int j=0;
    	for(size_t i=0; i<ref_read2.size();){
        if(indel2.count(k)==0){
           i++; k++; 
        }
        else if(indel2[k][0]=='-'){
        	int num = k+1;
        	string tem = boost::lexical_cast<string>(num);
        	delet_inf += tem + ",";
        	for(int l=0; l<indel2[k].size(); l++)
        	{
        		delet_inf += ref_read2[i+l];
        	}
        	delet_inf +=";";
          Read2_del_sum+=indel2[k].size(); 
          i+=indel2[k].size();k++;      		
        	
        }
        else{
        	int num = k+1;
        	string tem = boost::lexical_cast<string>(num);
        	inser_inf += tem + "," + indel2[k] + ";";
          Read2_ins_sum+=indel2[k].size();
          k+=indel2[k].size();
            
        }
    	}
    	while(indel2.count(k)>0){
        int num = k+1;
        string tem = boost::lexical_cast<string>(num);
        inser_inf += tem + "," + indel2[k] + ";";
				Read2_ins_sum+=indel2[k].size();
        k+=indel2[k].size();
    	}
    	if(inser_inf.empty()){
    		Infor_outfile<<"-"<<"\t";
    	}else{
    		Infor_outfile<<inser_inf<<"\t";
    	}
    	if(delet_inf.empty()){
    		Infor_outfile<<"-";
    	}else{
    		Infor_outfile<<delet_inf;
    	}
  	}
  	
  	Infor_outfile<<endl;
  	
  	//output reads
		if(!InputParameter.Output_type){
			//output read file1
			Outfile1<<id_header<<"read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1;
			Outfile1<<endl<<output_read1<<endl;
			if(InputParameter.Is_simulate_quality)
			{
  			Outfile1<<"+"<<endl
  				<<output_quality_seq1<<endl;
  		}
  		
  		//output read file2
			Outfile2<<id_header<<"read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2;
			Outfile2<<endl<<output_read2<<endl;
			if(InputParameter.Is_simulate_quality)
			{
  			Outfile2<<"+"<<endl
  				<<output_quality_seq2<<endl;
  		}
		}else{
			//*.gz output
			//output read file1
			Gz_outfile1<<id_header<<"read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1;
			Gz_outfile1<<endl<<output_read1<<endl;
			if(InputParameter.Is_simulate_quality)
			{
  			Gz_outfile1<<"+"<<endl
  				<<output_quality_seq1<<endl;
  		}
  		
  		//output read file2
			Gz_outfile2<<id_header<<"read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2;
			Gz_outfile2<<endl<<output_read2<<endl;
			if(InputParameter.Is_simulate_quality)
			{
  			Gz_outfile2<<"+"<<endl
  				<<output_quality_seq2<<endl;
  		}
		}
	}
	cerr<<"Finish output reads"<<endl;
	return reads_count;
}

